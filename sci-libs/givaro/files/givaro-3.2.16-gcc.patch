--- src/kernel/integer/givintnumtheo.inl
+++ src/kernel/integer/givintnumtheo.inl
@@ -22,8 +22,8 @@
 // =================================================================== //
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::phi(Rep& res, const Rep& n) const {
-    if (isleq(n,1)) return res=n;
-    if (isleq(n,3)) return sub(res,n,this->one);
+    if (this->isleq(n,1)) return res=n;
+    if (this->isleq(n,3)) return this->sub(res,n,this->one);
     std::list<Rep> Lf;
     Father_t::set(Lf,n);
     //return phi (res,Lf,n);
@@ -34,11 +34,11 @@
 template<class RandIter>
 template< template<class, class> class Container, template<class> class Alloc>
  typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::phi(Rep& res, const Container<Rep, Alloc<Rep> >& Lf, const Rep& n) const {
-    if (isleq(n,1)) return res=n;
-    if (isleq(n,3)) return sub(res,n,this->one);
+    if (this->isleq(n,1)) return res=n;
+    if (this->isleq(n,3)) return this->sub(res,n,this->one);
     res = n; Rep t,m;
     for(typename Container<Rep, Alloc<Rep> >::const_iterator f=Lf.begin(); f!=Lf.end(); ++f) 
-        mul(res, divexact(t,res,*f), sub(m, *f, this->one));
+        this->mul(res, this->divexact(t,res,*f), this->sub(m, *f, this->one));
     return res;
 }
 
@@ -85,7 +85,7 @@
         // n must be in {2,4,p^m,2p^m} where p is an odd prime
         // else infinite loop
 
-    if (isleq(n,4)) return sub(A,n,this->one);
+    if (isleq(n,4)) return this->sub(A,n,this->one);
     if (isZero(mod(A,n,4))) return A=this->zero;
     Rep p,ismod2, q, no2, root; 
     if (isZero(mod(ismod2,n,2))) divexact(no2,n,2); else no2=n;
@@ -139,7 +139,7 @@
     while (! found) {
        do {
             this->random(this->_g, A, p);
-            addin( modin(A,sub(tmp,p,7)) , 7);
+            addin( modin(A,this->sub(tmp,p,7)) , 7);
         } while ( ! isOne(gcd(tmp,A,p)) );
         found = ++runs;
         for(f=Lf.begin();(f!=Lf.end() && found);f++)
@@ -303,7 +303,7 @@
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::prim_root_of_prime(Rep& A, const Rep& n) const { 
     
     std::vector<Rep> Lf;
-    Rep phin; sub(phin,n,this->one);
+    Rep phin; this->sub(phin,n,this->one);
     Father_t::set(Lf,phin);
     return prim_root_of_prime(A, Lf, phin, n);
 }
@@ -407,8 +407,8 @@
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::lowest_prim_root(Rep& A, const Rep& n) const {
         // n must be in {2,4,p^m,2p^m} where p is an odd prime
         // else returns zero
-    if (isleq(n,4)) return sub(A,n,this->one);
-    if (isZero(mod(A,n,4))) return A=this->zero;
+    if (this->isleq(n,4)) return this->sub(A,n,this->one);
+    if (isZero(this->mod(A,n,4))) return A=this->zero;
     Rep phin, tmp; 
     phi(phin,n);
     std::list<Rep> Lf;
@@ -417,15 +417,15 @@
     for(f=Lf.begin();f!=Lf.end();++f)
             this->div(*f,phin,*f);
     int found=0;
-    for(A = 2;(isleq(A,n) && (! found));addin(A,1)) {
+    for(A = 2;(this->isleq(A,n) && (! found));this->addin(A,1)) {
         if (isOne(gcd(tmp,A,n))) {
             found = 1;
             for(f=Lf.begin();(f!=Lf.end() && found);f++)
                 found = (! isOne( this->powmod(tmp,A,*f,n)) );
         }
     }
-    if (isleq(A,n))
-        return subin(A,1);
+    if (this->isleq(A,n))
+        return this->subin(A,1);
     else
         return A=this->zero; 
 }
@@ -490,7 +490,7 @@
 
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::prim_inv(Rep& A, const Rep& n) const {
-    if (isleq(n,4)) return sub(A,n,this->one);
+    if (isleq(n,4)) return this->sub(A,n,this->one);
     if (areEqual(n,8)) return init(A,3);
     return prim_base(A, n);
 }
@@ -542,7 +542,7 @@
         return dom_power(z, p, e-2, *this);
     } else {
         Rep tmp;
-        return mulin( dom_power(z, p, e-1, *this), sub(tmp, p, this->one) );
+        return mulin( dom_power(z, p, e-1, *this), this->sub(tmp, p, this->one) );
     }
 }
 
@@ -555,7 +555,7 @@
         return dom_power(z, p, e-2, *this);
     } else {
         Rep tmp;
-        return mulin( dom_power(z, p, e-1, *this), sub(tmp, p, this->one) );
+        return mulin( dom_power(z, p, e-1, *this), this->sub(tmp, p, this->one) );
     }
 }
 
--- src/library/poly1/givpoly1factor.inl
+++ src/library/poly1/givpoly1factor.inl
@@ -29,7 +29,7 @@
     , Residu_t MOD) const {
 	typename Domain::Element one;
 	_domain.init(one, 1UL);
-    Degree dG;degree(dG,G);
+     Degree dG;this->degree(dG,G);
     if (dG == d)
         L.push_back(G);
     else {
@@ -37,7 +37,7 @@
         while (! splitted) {
             Rep tmp, G1;
             this->gcd(G1, G, this->random(_g, tmp, dG-1));
-            Degree dG1; degree(dG1,G1);
+            Degree dG1; this->degree(dG1,G1);
 // write(std::cerr << "SF rd: ", tmp) << std::endl;
 // write(std::cerr << "SF G1: ", G1) << std::endl;
             if ( dG1 != dG) {
@@ -49,8 +49,8 @@
                 Integer pp = (power(Integer(MOD), d.value()) - 1)/2;
 // std::cerr << "pp: " << pp << std::endl;
                 Rep tp, tp2, G2;
-                this->gcd(G2,G, sub(tp2, this->powmod(tp, tmp, pp, G) , one) );
-                Degree dG2; degree(dG2,G2);
+                this->gcd(G2,G, this->sub(tp2, this->powmod(tp, tmp, pp, G) , one) );
+                Degree dG2; this->degree(dG2,G2);
 // write(std::cerr << "SF t2: ", tp2) << std::endl;
 // write(std::cerr << "SF G2: ", G2) << std::endl;
                 if ( dG2 != dG) {
@@ -59,8 +59,8 @@
                         SplitFactor ( L, G2, d, MOD) ;
                     }
 // UNNECESSARY : ANYTHING FOUND BY G3 WOULD HAVE THE COFACTOR IN G2
-                     Rep G3; this->gcd(G3, G, add(tp2,tp,one) );
-                     Degree dG3; degree(dG3,G3);
+                     Rep G3; this->gcd(G3, G, this->add(tp2,tp,one) );
+                     Degree dG3; this->degree(dG3,G3);
 // write(std::cerr << "SF t3: ", tp2) << std::endl;
 // write(std::cerr << "SF G3: ", G3) << std::endl;
                      if (( dG3 != dG) && (dG3 > 0 )) {
@@ -138,21 +138,21 @@
 // write(std::cerr << "DD in: ", f) << std::endl;
     Rep W, D, P = f;
     Degree dP;
-    Rep Unit, G1; init(Unit, Degree(1), one);
+    Rep Unit, G1; this->init(Unit, Degree(1), one);
     W.copy(Unit);
-    degree(dP,P); Degree dPo = (dP/2);
+    this->degree(dP,P); Degree dPo = (dP/2);
     for(Degree dp = 1; dp <= dPo; ++dp) {
 // std::cerr << "DD degree: " << dp << std::endl;
         this->powmod(W, D.copy(W), MOD, P);
-        this->gcd (G1,sub(D,W,Unit), P) ;
-        Degree dG1; degree(dG1,G1);
+        this->gcd (G1,this->sub(D,W,Unit), P) ;
+        Degree dG1; this->degree(dG1,G1);
 // write(std::cerr << "DD found: ", G1) << ", of degree " << dG1 << std::endl;
         if ( dG1 > 0 ) {
             SplitFactor (L, G1, dp, MOD);
-            divin(P,G1);
+            this->divin(P,G1);
         }
     }
-    degree(dP,P);    
+    this->degree(dP,P);    
     if (dP > 0)
         L.push_back(P);
 // write(std::cerr << "DD: ", P) << std::endl;
@@ -170,10 +170,10 @@
 	       const Rep& P,
 	       Residu_t MOD)  const {
 // write(std::cerr << "CZ in: ", P) << std::endl;
-    Degree dp; degree(dp,P);
+    Degree dp; this->degree(dp,P);
     size_t nb=dp.value()+1; 
     Rep * g = new Rep[nb];
-    sqrfree(nb,g,P);
+    this->sqrfree(nb,g,P);
 // std::cerr << "CZ sqrfree: " << nb << std::endl;
     for(size_t i = 0; i<nb;++i) {
         size_t this_multiplicity = Lf.size();
@@ -205,17 +205,17 @@
         // Square free ?
    typename Domain::Element _one;
    _domain.init(_one,1UL); 
-   Rep W,D; this->gcd(W,diff(D,P),P);
+   Rep W,D; this->gcd(W,this->diff(D,P),P);
     Degree d, dP;
-    if (degree(d,W) > 0) return 0;
+    if (this->degree(d,W) > 0) return 0;
         // Distinct degree free ?
-    Rep Unit, G1; init(Unit, Degree(1), _one);
+    Rep Unit, G1; this->init(Unit, Degree(1), _one);
     W.copy(Unit);
-    degree(dP,P); Degree dPo = (dP/2);
+    this->degree(dP,P); Degree dPo = (dP/2);
     for(Degree dp = 1; dp <= dPo; ++dp) {
         this->powmod(W, D.copy(W), MOD, P);
-        this->gcd (G1, sub(D,W,Unit), P) ;
-        if ( degree(d,G1) > 0 ) return 0;
+        this->gcd (G1, this->sub(D,W,Unit), P) ;
+        if ( this->degree(d,G1) > 0 ) return 0;
     }
     return 1;
 }

--- src/library/poly1/givpoly1proot.inl
+++ src/library/poly1/givpoly1proot.inl
@@ -33,7 +33,7 @@
 
 template<class Domain, class Tag, class RandIter >
 inline typename Poly1FactorDom<Domain,Tag, RandIter>::Element& Poly1FactorDom<Domain,Tag, RandIter>::creux_random_irreducible (Element& R, Degree n) const {
-    init(R, n, _domain.one);
+    this->init(R, n, _domain.one);
     Residu_t MOD = _domain.residu();
 
         // Search for an irreducible BINOMIAL : X^n + a
@@ -80,7 +80,7 @@
 inline typename Poly1FactorDom<Domain,Tag, RandIter>::Element& Poly1FactorDom<Domain,Tag, RandIter>::random_irreducible (Element& R, Degree n) const {
         // Search for a monic irreducible Polynomial
         // with random Elements
-    init(R, n, _domain.one);
+    this->init(R, n, _domain.one);
     Residu_t MOD = _domain.residu();
 
     do {
@@ -102,9 +102,9 @@
 // ---------------------------------------------------------------
 template<class Domain, class Tag, class RandIter >
 inline typename Poly1FactorDom<Domain,Tag, RandIter>::Element& Poly1FactorDom<Domain,Tag, RandIter>::ixe_irreducible (Element& R, Degree n) const {
-    init(R, n, _domain.one);
+    this->init(R, n, _domain.one);
     Element IXE;
-    init(IXE,Degree(1),_domain.one);
+    this->init(IXE,Degree(1),_domain.one);
     Residu_t MOD = _domain.residu();
 
         // Search for an irreducible BINOMIAL : X^n + a
@@ -234,13 +234,13 @@
 template<class Domain, class Tag, class RandIter>
 bool Poly1FactorDom<Domain,Tag, RandIter>::is_prim_root( const Rep& P, const Rep& F)  const {
     bool isproot = 0;
-    Rep A, G; mod(A,P,F);
+    Rep A, G; this->mod(A,P,F);
     Degree d;
-    if ( degree(d, this->gcd(G,A,F)) == 0) {
+    if ( this->degree(d, this->gcd(G,A,F)) == 0) {
         Residu_t MOD = _domain.residu();
         IntFactorDom<> FD;
         IntFactorDom<>::Element IMOD( MOD ), q, qp;
-        degree(d,F);
+        this->degree(d,F);
 //         FD.pow(q ,IMOD, d.value());
 //         FD.sub(qp, q, FD.one);
         FD.subin( FD.pow(qp ,IMOD, d.value()) , FD.one);
@@ -291,14 +291,14 @@
 
 template<class Domain, class Tag, class RandIter >
 inline typename Poly1FactorDom<Domain,Tag, RandIter>::Rep& Poly1FactorDom<Domain,Tag, RandIter>::give_prim_root(Rep& R, const Rep& F)  const {
-    Degree n; degree(n,F);
+    Degree n; this->degree(n,F);
     Residu_t MOD = _domain.residu();
 //    this->write(std::cout << "Give Pr: ", F) << std::endl;
     
     
         // Search for a primitive BINOMIAL : X^i + a
     for(Degree di=1;di<n;++di) {
-        init(R, di, _domain.one);
+        this->init(R, di, _domain.one);
 //         for(Residu_t a=MOD; a--; ) {
         for(Residu_t a=0; a<MOD;++a ) {
             _domain.assign(R[0],a);
@@ -308,7 +308,7 @@
     }
         // Search for a primitive TRINOMIAL : X^i + b*X^j + a
     for(Degree di=2;di<n;++di) {
-        init(R, di, _domain.one);
+        this->init(R, di, _domain.one);
         for(Degree dj=1;dj<di;++dj)
 //             for(Residu_t b=MOD; b--;) {
             for(Residu_t b=0; b<MOD;++b) {
