# HG changeset patch
# User Nils Bruin <nbruin@sfu.ca>
# Date 1296857997 28800
# Node ID 958099d5542a134fb7ca17918e2a8e51a174d405
# Parent  55e87dcbd144bc31d5256c610bab499a88b0e35e
Add iterator protocol to EclObject
* * *
Fix doctesting of printing ECL floats

diff -r 55e87dcbd144 -r 958099d5542a sage/libs/ecl.pyx
--- sage/libs/ecl.pyx	Mon Jan 31 09:38:28 2011 -0800
+++ sage/libs/ecl.pyx	Fri Feb 04 14:19:57 2011 -0800
@@ -401,9 +401,20 @@
         <ECL: 1>
         sage: EclObject(10**40)
         <ECL: 10000000000000000000000000000000000000000>
-        sage: EclObject(float(10**40))
+
+    Floats in Python are IEEE double, which LISP has as well. However,
+    the printing of floating point types in LISP depends on settings::
+
+        sage: a = EclObject(float(10**40))
+        sage: ecl_eval("(setf *read-default-float-format* 'single-float)")
+        <ECL: SINGLE-FLOAT>
+        sage: a
         <ECL: 9.999999999999999d39>
-
+        sage: ecl_eval("(setf *read-default-float-format* 'double-float)")
+        <ECL: DOUBLE-FLOAT>
+        sage: a
+        <ECL: 9.999999999999999E39>
+
     Tuples are translated to dotted lists::

         sage: EclObject( (false, true))
@@ -656,6 +667,44 @@
         #else:
         #    raise ValueError,"richcmp received operation code %d"%op

+    def __iter__(self):
+        r"""
+        Implements the iterator protocol for EclObject.
+
+        EclObject implements the iterator protocol for lists. This means
+        one can use an EclObject in the context where an iterator is
+        expected (for instance, in a list comprehension or in a for loop).
+        The iterator produces EclObjects wrapping the members of the list that
+        the original EclObject wraps.
+
+        The wrappers returned are all newly constructed but refer to the
+        original members of the list iterated over. This is usually what is
+        intended but, just as in Python, can cause surprises if the original
+        object is changed between calls to the iterator.
+
+        Since EclObject translates Python Lists into LISP lists and Python
+        tuples into LISP "dotted" lists (lists for which the final CDR is not
+        necessarily NIL), and both these python structures are iterable, the
+        corresponding EclObjects are iterable as well.
+
+        EclObjects that are not lists are not iterable.
+
+        EXAMPLES::
+            sage: from sage.libs.ecl import *
+            sage: [i for i in EclObject("(1 2 3)")]
+            [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+            sage: [i for i in EclObject("(1 2 . 3)")]
+            [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+            sage: [i for i in EclObject("NIL")]
+            []
+            sage: [i for i in EclObject("T")]
+            Traceback (most recent call last):
+            ...
+            TypeError: ECL object is not iterable
+
+        """
+        return EclListIterator(self)
+
     def eval(self):
         r"""
         Evaluate object as an S-Expression
@@ -984,6 +1033,96 @@
         """
         return bint_symbolp(self.obj)

+cdef class EclListIterator:
+    r"""
+    Iterator object for an ECL list
+
+    This class is used to implement the iterator protocol for EclObject.
+    Do not instantiate this class directly but use the iterator method
+    on an EclObject instead. It is an error if the EclObject is not a list.
+
+    EXAMPLES::
+
+        sage: from sage.libs.ecl import *
+        sage: I=EclListIterator(EclObject("(1 2 3)"))
+        sage: type(I)
+        <type 'sage.libs.ecl.EclListIterator'>
+        sage: [i for i in I]
+        [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+        sage: [i for i in EclObject("(1 2 3)")]
+        [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+        sage: EclListIterator(EclObject("1"))
+        Traceback (most recent call last):
+        ...
+        TypeError: ECL object is not iterable
+
+    """
+    cdef EclObject current
+
+    def __init__(EclListIterator self, EclObject o):
+        r"""
+        Initialize EclListIterator
+
+        EXAMPLES::
+
+            sage: from sage.libs.ecl import *
+            sage: I=EclListIterator(EclObject("(1 2 3)"))
+            sage: type(I)
+            <type 'sage.libs.ecl.EclListIterator'>
+
+        """
+        if not o.listp():
+            raise TypeError,"ECL object is not iterable"
+        self.current = ecl_wrap(o.obj)
+
+    def __iter__(EclListIterator self):
+        r"""
+        Return self
+
+        It seems standard that iterators return themselves if asked to produce
+        an iterator.
+
+        EXAMPLES::
+
+            sage: from sage.libs.ecl import *
+            sage: I=EclListIterator(EclObject("(1 2 3)"))
+            sage: id(I) == id(I.__iter__())
+            True
+
+        """
+        return self
+
+    def __next__(EclListIterator self):
+        r"""
+        Get next element from iterator
+
+        EXAMPLES::
+
+            sage: from sage.libs.ecl import *
+            sage: I=EclListIterator(EclObject("(1 2 3)"))
+            sage: I.next()
+            <ECL: 1>
+            sage: I.next()
+            <ECL: 2>
+            sage: I.next()
+            <ECL: 3>
+            sage: I.next()
+            Traceback (most recent call last):
+            ...
+            StopIteration
+
+        """
+
+        if self.current.nullp():
+            raise StopIteration
+        elif self.current.consp():
+            r = self.current.car()
+            self.current = self.current.cdr()
+        else:
+            r = self.current
+            self.current = ecl_wrap(Cnil)
+        return r
+
 #input: a cl-object. Output: EclObject wrapping that.
 cdef EclObject ecl_wrap(cl_object o):
     cdef EclObject obj = EclObject.__new__(EclObject)
